<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Pro - K4 Games</title>
    <style>
        :root {
            --bg-color: #0f0f12;
            --panel-bg: #1a1a20;
            --text-color: #ffffff;
            --border-color: #333;
            --accent-color: #00f0f0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        canvas {
            border: 2px solid var(--border-color);
            background-color: #000;
            display: block;
        }

        #side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 120px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #aaa;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
        }

        #next-canvas {
            background: #000;
            border: 1px solid var(--border-color);
            margin-top: 10px;
        }

        /* Mobile Controls */
        #controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
        }

        .btn {
            background: #333;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 8px;
            font-size: 1.2rem;
            text-align: center;
            user-select: none;
        }

        .btn:active { background: #555; }
        .btn-large { grid-column: span 3; background: #444; }

        @media (max-width: 600px) {
            #game-container {
                flex-direction: column;
                padding: 10px;
            }
            #side-panel {
                flex-direction: row;
                justify-content: space-around;
                min-width: auto;
            }
            #controls { display: grid; }
            canvas { width: 200px; height: 400px; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="tetris"></canvas>
    
    <div id="side-panel">
        <div class="stat-box">
            <div class="stat-label">Next</div>
            <canvas id="next-canvas" width="80" height="80"></canvas>
        </div>
        <div class="stat-box">
            <div class="stat-label">Score</div>
            <div id="score" class="stat-value">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Level</div>
            <div id="level" class="stat-value">1</div>
        </div>
    </div>
</div>

<div id="controls">
    <div class="btn" id="left">◀</div>
    <div class="btn" id="rotate">↻</div>
    <div class="btn" id="right">▶</div>
    <div class="btn" id="down">▼</div>
    <div class="btn" id="drop">DROP</div>
</div>

<script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next-canvas');
    const nextContext = nextCanvas.getContext('2d');

    const ROW = 20;
    const COL = 10;
    const SQ = 30; // Square size

    canvas.width = COL * SQ;
    canvas.height = ROW * SQ;

    const COLORS = {
        'I': '#00f0f0',
        'J': '#0000f0',
        'L': '#f0a000',
        'O': '#f0f000',
        'S': '#00f000',
        'T': '#a000f0',
        'R': '#f00000'
    };

    const PIECES = [
        [ [0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0], 'I' ],
        [ [1,0,0],[1,1,1],[0,0,0], 'J' ],
        [ [0,0,1],[1,1,1],[0,0,0], 'L' ],
        [ [1,1],[1,1], 'O' ],
        [ [0,1,1],[1,1,0],[0,0,0], 'S' ],
        [ [0,1,0],[1,1,1],[0,0,0], 'T' ],
        [ [1,1,0],[0,1,1],[0,0,0], 'R' ]
    ];

    let board = [];
    for(r = 0; r < ROW; r++){
        board[r] = [];
        for(c = 0; c < COL; c++){
            board[r][c] = null;
        }
    }

    function drawSquare(x, y, color, ctx = context, isGhost = false){
        ctx.fillStyle = color;
        if (isGhost) {
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x*SQ + 2, y*SQ + 2, SQ - 4, SQ - 4);
            ctx.globalAlpha = 1.0;
        } else {
            ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            
            // Highlight
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillRect(x*SQ, y*SQ, SQ, SQ/4);
        }
    }

    function drawBoard(){
        for(r = 0; r < ROW; r++){
            for(c = 0; c < COL; c++){
                if(board[r][c]){
                    drawSquare(c, r, board[r][c]);
                }
            }
        }
    }

    class Piece {
        constructor(tetromino, color){
            this.tetromino = tetromino;
            this.color = color;
            this.activeTetromino = this.tetromino;
            this.x = 3;
            this.y = -2;
        }

        draw(isGhost = false, ghostY = null){
            const yPos = isGhost ? ghostY : this.y;
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(this.activeTetromino[r][c]){
                        drawSquare(this.x + c, yPos + r, this.color, context, isGhost);
                    }
                }
            }
        }

        collision(x, y, piece){
            for(let r = 0; r < piece.length; r++){
                for(let c = 0; c < piece.length; c++){
                    if(!piece[r][c]) continue;
                    let newX = this.x + c + x;
                    let newY = this.y + r + y;
                    if(newX < 0 || newX >= COL || newY >= ROW) return true;
                    if(newY < 0) continue;
                    if(board[newY][newX]) return true;
                }
            }
            return false;
        }

        moveDown(){
            if(!this.collision(0, 1, this.activeTetromino)){
                this.y++;
            } else {
                this.lock();
                p = nextP;
                nextP = randomPiece();
                drawNext();
            }
        }

        moveRight(){
            if(!this.collision(1, 0, this.activeTetromino)) this.x++;
        }

        moveLeft(){
            if(!this.collision(-1, 0, this.activeTetromino)) this.x--;
        }

        rotate(){
            let nextPattern = [];
            for(let i=0; i<this.activeTetromino.length; i++){
                nextPattern[i] = [];
                for(let j=0; j<this.activeTetromino.length; j++){
                    nextPattern[i][j] = this.activeTetromino[this.activeTetromino.length - j - 1][i];
                }
            }
            
            let kick = 0;
            if(this.collision(0, 0, nextPattern)){
                if(this.x > COL/2) kick = -1;
                else kick = 1;
            }
            
            if(!this.collision(kick, 0, nextPattern)){
                this.x += kick;
                this.activeTetromino = nextPattern;
            }
        }

        lock(){
            for(let r = 0; r < this.activeTetromino.length; r++){
                for(let c = 0; c < this.activeTetromino.length; c++){
                    if(!this.activeTetromino[r][c]) continue;
                    if(this.y + r < 0){
                        alert("Game Over");
                        gameOver = true;
                        break;
                    }
                    board[this.y + r][this.x + c] = this.color;
                }
            }
            // Check lines
            let lines = 0;
            for(let r = 0; r < ROW; r++){
                let isFull = true;
                for(let c = 0; c < COL; c++){
                    if(!board[r][c]) isFull = false;
                }
                if(isFull){
                    lines++;
                    for(let y = r; y > 1; y--){
                        for(let c = 0; c < COL; c++){
                            board[y][c] = board[y-1][c];
                        }
                    }
                    for(let c = 0; c < COL; c++) board[0][c] = null;
                }
            }
            if(lines > 0){
                score += [0, 100, 300, 500, 800][lines];
                document.getElementById('score').innerText = score;
                if(score > level * 1000) level++;
                document.getElementById('level').innerText = level;
            }
        }

        getGhostY(){
            let gy = this.y;
            while(!this.collision(0, gy - this.y + 1, this.activeTetromino)){
                gy++;
            }
            return gy;
        }
    }

    function randomPiece(){
        let r = Math.floor(Math.random() * PIECES.length);
        return new Piece(PIECES[r].slice(0, PIECES[r].length - 1), COLORS[PIECES[r][PIECES[r].length-1]]);
    }

    let p = randomPiece();
    let nextP = randomPiece();
    let score = 0;
    let level = 1;
    let gameOver = false;
    let dropStart = Date.now();

    function drawNext(){
        nextContext.clearRect(0, 0, 80, 80);
        const s = 15;
        nextContext.fillStyle = nextP.color;
        for(let r = 0; r < nextP.activeTetromino.length; r++){
            for(let c = 0; c < nextP.activeTetromino.length; c++){
                if(nextP.activeTetromino[r][c]){
                    nextContext.fillRect(10 + c*s, 10 + r*s, s, s);
                    nextContext.strokeRect(10 + c*s, 10 + r*s, s, s);
                }
            }
        }
    }

    function update(){
        if(gameOver) return;
        let now = Date.now();
        let delta = now - dropStart;
        let speed = Math.max(100, 1000 - (level * 100));
        if(delta > speed){
            p.moveDown();
            dropStart = Date.now();
        }
        
        context.clearRect(0,0, canvas.width, canvas.height);
        drawBoard();
        p.draw(true, p.getGhostY()); // Draw Ghost
        p.draw(); // Draw Active
        
        requestAnimationFrame(update);
    }

    document.addEventListener("keydown", (e) => {
        if(e.keyCode == 37) p.moveLeft();
        else if(e.keyCode == 38) p.rotate();
        else if(e.keyCode == 39) p.moveRight();
        else if(e.keyCode == 40) p.moveDown();
        else if(e.keyCode == 32) { // Space - Hard Drop
            p.y = p.getGhostY();
            p.lock();
            p = nextP;
            nextP = randomPiece();
            drawNext();
        }
    });

    // Touch Controls
    document.getElementById('left').onclick = () => p.moveLeft();
    document.getElementById('right').onclick = () => p.moveRight();
    document.getElementById('rotate').onclick = () => p.rotate();
    document.getElementById('down').onclick = () => p.moveDown();
    document.getElementById('drop').onclick = () => {
        p.y = p.getGhostY();
        p.lock();
        p = nextP;
        nextP = randomPiece();
        drawNext();
    };

    drawNext();
    update();
</script>
</body>
</html>
