<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Elite - K2 games</title>
    <style>
        :root {
            --bg: #020617;
            --panel: #1e293b;
            --primary: #3b82f6;
            --accent: #fbbf24;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
        
        body {
            background-color: var(--bg);
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-image: radial-gradient(circle at center, #1e1b4b 0%, #020617 100%);
        }

        nav {
            height: 60px;
            padding: 0 1.5rem;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            border-bottom: 1px solid var(--border);
        }

        .logo { font-weight: 900; font-size: 1.2rem; color: #fff; letter-spacing: -0.5px; }
        .back-link { color: #94a3b8; text-decoration: none; font-size: 0.8rem; font-weight: bold; }

        #game-layout {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
        }

        #board-container {
            background: #000;
            border: 4px solid #334155;
            border-radius: 12px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            position: relative;
        }

        canvas { display: block; }

        /* Side Panels */
        #side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 140px;
        }

        .panel-box {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .box-label { font-size: 0.65rem; text-transform: uppercase; color: #94a3b8; letter-spacing: 1px; margin-bottom: 8px; font-weight: 800; }
        .box-val { font-size: 1.5rem; font-weight: 900; font-family: monospace; color: var(--accent); }

        #next-queue {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .next-preview { width: 60px; height: 60px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }

        /* Controls */
        #mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
            max-width: 320px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .btn {
            background: #334155; color: white; border: none; padding: 15px; border-radius: 12px;
            font-size: 1.5rem; font-weight: bold; cursor: pointer;
        }
        .btn:active { background: var(--primary); }
        .btn-wide { grid-column: span 3; background: #475569; }

        @media (max-width: 768px) {
            #game-layout { flex-direction: column; padding: 10px; gap: 10px; }
            #side-panel { flex-direction: row; width: 100%; justify-content: center; }
            #mobile-controls { display: grid; }
            #board-container { scale: 0.8; }
        }
    </style>
</head>
<body>
    <nav>
        <div class="logo">K2 TETRIS ELITE</div>
        <a href="index.html" class="back-link">← EXIT HUB</a>
    </nav>

    <div id="game-layout">
        <div id="board-container">
            <canvas id="tetris"></canvas>
        </div>

        <div id="side-panel">
            <div class="panel-box">
                <div class="box-label">Next Up</div>
                <div id="next-queue">
                    <canvas class="next-preview" id="next-0" width="60" height="60"></canvas>
                    <canvas class="next-preview" id="next-1" width="60" height="60"></canvas>
                    <canvas class="next-preview" id="next-2" width="60" height="60"></canvas>
                </div>
            </div>
            
            <div style="display:flex; flex-direction:column; gap:10px;">
                <div class="panel-box">
                    <div class="box-label">Score</div>
                    <div id="score" class="box-val">0</div>
                </div>
                <div class="panel-box">
                    <div class="box-label">Level</div>
                    <div id="level" class="box-val">1</div>
                </div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <button class="btn" id="ctrl-left">◀</button>
        <button class="btn" id="ctrl-rotate">↻</button>
        <button class="btn" id="ctrl-right">▶</button>
        <button class="btn" id="ctrl-down">▼</button>
        <button class="btn btn-wide" id="ctrl-drop">HARD DROP</button>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const ROW = 20, COL = 10, SQ = 30;
        canvas.width = COL * SQ; canvas.height = ROW * SQ;

        const COLORS = {
            I: '#0ea5e9', J: '#3b82f6', L: '#f97316', O: '#fbbf24', S: '#22c55e', T: '#a855f7', Z: '#ef4444'
        };

        const PIECES = {
            I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            J: [[1,0,0],[1,1,1],[0,0,0]],
            L: [[0,0,1],[1,1,1],[0,0,0]],
            O: [[1,1],[1,1]],
            S: [[0,1,1],[1,1,0],[0,0,0]],
            T: [[0,1,0],[1,1,1],[0,0,0]],
            Z: [[1,1,0],[0,1,1],[0,0,0]]
        };

        class Piece {
            constructor(type) {
                this.type = type;
                this.matrix = PIECES[type];
                this.color = COLORS[type];
                this.x = Math.floor(COL/2) - Math.floor(this.matrix[0].length/2);
                this.y = -1;
            }

            draw(context, offset = {x:0, y:0}, ghost = false) {
                this.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            context.fillStyle = this.color;
                            if (ghost) {
                                context.globalAlpha = 0.15;
                                context.strokeStyle = this.color;
                                context.lineWidth = 2;
                                context.strokeRect((this.x + x + offset.x)*SQ + 2, (this.y + y + offset.y)*SQ + 2, SQ - 4, SQ - 4);
                                context.globalAlpha = 1.0;
                            } else {
                                context.fillRect((this.x + x + offset.x)*SQ, (this.y + y + offset.y)*SQ, SQ, SQ);
                                context.strokeStyle = 'rgba(0,0,0,0.2)';
                                context.strokeRect((this.x + x + offset.x)*SQ, (this.y + y + offset.y)*SQ, SQ, SQ);
                                // Shading
                                context.fillStyle = 'rgba(255,255,255,0.1)';
                                context.fillRect((this.x + x + offset.x)*SQ, (this.y + y + offset.y)*SQ, SQ, 4);
                            }
                        }
                    });
                });
            }
        }

        class Game {
            constructor() {
                this.grid = Array.from({length: ROW}, () => Array(COL).fill(0));
                this.queue = [];
                this.piece = null;
                this.score = 0;
                this.level = 1;
                this.gameOver = false;
                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.lastTime = 0;

                this.fillQueue();
                this.nextPiece();
                this.setupInputs();
            }

            fillQueue() {
                const types = Object.keys(PIECES);
                while(this.queue.length < 4) {
                    const bag = [...types].sort(() => Math.random() - 0.5);
                    this.queue.push(...bag);
                }
            }

            nextPiece() {
                const type = this.queue.shift();
                this.piece = new Piece(type);
                this.fillQueue();
                this.drawPreviews();
                if (this.collide()) {
                    this.gameOver = true;
                    alert("GAME OVER! Score: " + this.score);
                    location.reload();
                }
            }

            drawPreviews() {
                for(let i=0; i<3; i++) {
                    const ctxP = document.getElementById(`next-${i}`).getContext('2d');
                    ctxP.clearRect(0,0,60,60);
                    const type = this.queue[i];
                    const matrix = PIECES[type];
                    const s = 12;
                    ctxP.fillStyle = COLORS[type];
                    matrix.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if(val) ctxP.fillRect(10 + x*s, 10 + y*s, s, s);
                        });
                    });
                }
            }

            collide(p = this.piece, ox = 0, oy = 0) {
                const m = p.matrix;
                for(let y=0; y<m.length; y++) {
                    for(let x=0; x<m[y].length; x++) {
                        if(m[y][x]) {
                            const ny = p.y + y + oy;
                            const nx = p.x + x + ox;
                            if(ny >= ROW || nx < 0 || nx >= COL || (ny >= 0 && this.grid[ny][nx])) return true;
                        }
                    }
                }
                return false;
            }

            rotate() {
                const m = this.piece.matrix;
                const next = m[0].map((_, i) => m.map(row => row[i]).reverse());
                const prev = this.piece.matrix;
                this.piece.matrix = next;
                if (this.collide()) this.piece.matrix = prev;
            }

            lock() {
                this.piece.matrix.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if(val) {
                            const ny = this.piece.y + y;
                            if (ny >= 0) this.grid[ny][this.piece.x + x] = this.piece.color;
                        }
                    });
                });
                this.clearLines();
                this.nextPiece();
            }

            clearLines() {
                let count = 0;
                for(let y=ROW-1; y>=0; y--) {
                    if(this.grid[y].every(cell => cell !== 0)) {
                        this.grid.splice(y, 1);
                        this.grid.unshift(Array(COL).fill(0));
                        y++;
                        count++;
                    }
                }
                if(count > 0) {
                    this.score += [0, 100, 300, 500, 800][count] * this.level;
                    document.getElementById('score').textContent = this.score;
                    this.level = Math.floor(this.score / 1000) + 1;
                    document.getElementById('level').textContent = this.level;
                    this.dropInterval = Math.max(100, 1000 - (this.level-1)*100);
                }
            }

            drop() {
                if(!this.collide(this.piece, 0, 1)) {
                    this.piece.y++;
                } else {
                    this.lock();
                }
                this.dropCounter = 0;
            }

            hardDrop() {
                while(!this.collide(this.piece, 0, 1)) this.piece.y++;
                this.lock();
            }

            setupInputs() {
                window.onkeydown = e => {
                    if(e.key === 'ArrowLeft') if(!this.collide(this.piece, -1, 0)) this.piece.x--;
                    if(e.key === 'ArrowRight') if(!this.collide(this.piece, 1, 0)) this.piece.x++;
                    if(e.key === 'ArrowDown') this.drop();
                    if(e.key === 'ArrowUp') this.rotate();
                    if(e.key === ' ') this.hardDrop();
                };
                
                const addBtn = (id, fn) => document.getElementById(id).onclick = fn;
                addBtn('ctrl-left', () => { if(!this.collide(this.piece, -1, 0)) this.piece.x--; });
                addBtn('ctrl-right', () => { if(!this.collide(this.piece, 1, 0)) this.piece.x++; });
                addBtn('ctrl-rotate', () => this.rotate());
                addBtn('ctrl-down', () => this.drop());
                addBtn('ctrl-drop', () => this.hardDrop());
            }

            getGhostY() {
                let gy = this.piece.y;
                while(!this.collide(this.piece, 0, gy - this.piece.y + 1)) gy++;
                return gy;
            }

            draw() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                
                // Grid Lines
                ctx.strokeStyle = 'rgba(255,255,255,0.02)';
                for(let x=0; x<COL; x++) ctx.strokeRect(x*SQ, 0, SQ, canvas.height);
                for(let y=0; y<ROW; y++) ctx.strokeRect(0, y*SQ, canvas.width, SQ);

                // Locked Blocks
                this.grid.forEach((row, y) => {
                    row.forEach((color, x) => {
                        if(color) {
                            ctx.fillStyle = color;
                            ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
                            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
                        }
                    });
                });

                // Ghost
                this.piece.draw(ctx, {x:0, y:this.getGhostY() - this.piece.y}, true);
                // Active
                this.piece.draw(ctx);
            }

            update(time = 0) {
                const dt = time - this.lastTime;
                this.lastTime = time;
                this.dropCounter += dt;
                if(this.dropCounter > this.dropInterval) this.drop();
                this.draw();
                requestAnimationFrame(t => this.update(t));
            }
        }

        const game = new Game();
        game.update();
    </script>
</body>
</html>
