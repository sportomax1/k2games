<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key Fly: Keyboard Invasion - K4 Games</title>
    <style>
        :root {
            --primary: #6366f1;
            --secondary: #a855f7;
            --accent: #f59e0b;
            --danger: #ef4444;
            --success: #10b981;
            --bg: #0f172a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            background-color: var(--bg);
            background-image: 
                radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.15) 0, transparent 50%),
                radial-gradient(at 100% 100%, rgba(168, 85, 247, 0.15) 0, transparent 50%);
            color: white;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Hide bugs that go off the browser window */
        }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .stat-card {
            background: var(--glass);
            backdrop-filter: blur(12px);
            padding: 12px 25px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            text-align: center;
            min-width: 140px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .stat-val { font-size: 1.8rem; font-weight: 900; color: var(--accent); font-family: 'JetBrains Mono', monospace; }
        .stat-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.6; margin-top: 2px; }

        /* --- Playing Area --- */
        #game-view {
            perspective: 1200px;
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
        }

        #keyboard-container {
            position: relative;
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--glass-border);
            border-radius: 32px;
            padding: 60px; /* Increased padding */
            box-shadow: 0 50px 100px -20px rgba(0,0,0,0.7);
            transform: rotateX(15deg);
            transition: transform 0.5s ease;
            transform-style: preserve-3d;
            /* REMOVED overflow: hidden to let bugs fly in from outside the visual board */
        }

        .key-row { display: flex; justify-content: center; gap: 12px; margin-bottom: 12px; transform-style: preserve-3d; }

        .key-box {
            width: 75px; height: 75px;
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 1px solid #334155;
            border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #94a3b8; font-weight: 900; font-size: 1.3rem;
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 6px 0 #000, 0 8px 15px rgba(0,0,0,0.4);
            transform: translateZ(0px);
        }

        .key-box.active {
            transform: translateY(4px) translateZ(-5px);
            box-shadow: 0 2px 0 #000;
            background: #334155;
            color: #fff;
        }

        .key-box.hit { 
            background: var(--success) !important; 
            border-color: #34d399; color: white !important;
            box-shadow: 0 0 40px var(--success);
        }
        .key-box.miss { 
            background: var(--danger) !important; 
            border-color: #f87171; color: white !important;
            box-shadow: 0 0 40px var(--danger);
        }

        .key-label { font-size: 0.6rem; opacity: 0.5; position: absolute; top: 8px; left: 8px; }
        .key-space { width: 340px; }

        /* --- Bug Styling --- */
        .bug {
            position: absolute;
            font-size: 50px;
            z-index: 500; /* High z-index */
            pointer-events: none;
            will-change: transform;
            filter: drop-shadow(0 20px 25px rgba(0,0,0,0.6));
            /* Physically pop them forward in 3D space so they are ABOVE the keys */
            transform: translateZ(150px); 
            transition: transform 0.1s linear;
        }

        .splat {
            position: absolute;
            font-size: 70px;
            z-index: 600;
            pointer-events: none;
            transform: translateZ(160px);
            animation: splatAnim 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes splatAnim {
            0% { transform: scale(0.5) translateZ(160px) rotate(0deg); opacity: 0; }
            30% { transform: scale(1.5) translateZ(160px) rotate(20deg); opacity: 1; }
            100% { transform: scale(2) translateZ(160px) rotate(-10deg); opacity: 0; }
        }

        #game-overlay {
            position: absolute; inset: 0;
            background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(15px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 2000; text-align: center; border-radius: 32px;
            transform: translateZ(200px);
        }

        .btn-main {
            background: var(--accent); color: #000; border: none;
            padding: 18px 50px; border-radius: 50px; font-weight: 900;
            font-size: 1.4rem; cursor: pointer; transition: 0.2s;
            box-shadow: 0 15px 30px -5px rgba(245, 158, 11, 0.4);
            margin-top: 30px;
        }
        .btn-main:hover { transform: scale(1.05); filter: brightness(1.1); }

        .back-link {
            position: fixed; top: 30px; left: 30px; color: white; text-decoration: none;
            background: var(--glass); padding: 12px 25px; border-radius: 12px; z-index: 3000;
            font-weight: bold; border: 1px solid var(--glass-border); backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê HUB</a>

    <div id="hud">
        <div class="stat-card">
            <div id="score-val" class="stat-val">0</div>
            <div class="stat-label">SMASHED</div>
        </div>
        <div class="stat-card">
            <div id="combo-val" class="stat-val" style="color: var(--secondary)">x1</div>
            <div class="stat-label">COMBO</div>
        </div>
        <div class="stat-card">
            <div id="timer-val" class="stat-val" style="color: var(--success)">00:00</div>
            <div class="stat-label">SURVIVAL</div>
        </div>
    </div>

    <div id="game-view">
        <div id="keyboard-container">
            <div id="game-overlay">
                <h1 style="font-size: 5rem; font-weight: 900; letter-spacing: -3px; color: var(--accent);">KEY FLY</h1>
                <p id="high-score-txt" style="font-size: 1.2rem; opacity: 0.6; margin-top: -10px;">Best: 0 Smashed</p>
                <button class="btn-main" onclick="game.start()">START DEFENSE</button>
            </div>
            <!-- Rows generated by JS -->
        </div>
    </div>

    <script>
        const INSECTS = ['ü™∞', 'ü¶ü', 'ü¶ó', 'üêõ', 'üï∑Ô∏è', 'ü¶ã', 'üêú', 'ü™≤', 'üêû', 'üêù'];
        const ROWS = [
            ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
            ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
            ['Z', 'X', 'C', 'V', 'B', 'N', 'M'],
            ['SPACE']
        ];

        class Game {
            constructor() {
                this.kb = document.getElementById('keyboard-container');
                this.overlay = document.getElementById('game-overlay');
                
                this.score = 0;
                this.combo = 1;
                this.best = parseInt(localStorage.getItem('keyfly-best') || 0);
                this.startTime = 0;
                this.isPlaying = false;
                
                this.bugs = [];
                this.keys = new Map();
                this.pressed = new Set();

                this.init();
            }

            init() {
                this.renderKeyboard();
                this.setupInputs();
                document.getElementById('high-score-txt').textContent = `Best: ${this.best} Smashed`;
                this.loop();
            }

            renderKeyboard() {
                ROWS.forEach(row => {
                    const rowEl = document.createElement('div');
                    rowEl.className = 'key-row';
                    row.forEach(key => {
                        const k = document.createElement('div');
                        k.className = 'key-box' + (key === 'SPACE' ? ' key-space' : '');
                        k.innerHTML = `<span class="key-label">${key === 'SPACE' ? '‚ê£' : key}</span>${key === 'SPACE' ? 'SPACE' : key}`;
                        rowEl.appendChild(k);
                        this.keys.set(key, k);
                    });
                    this.kb.appendChild(rowEl);
                });
            }

            setupInputs() {
                window.onkeydown = (e) => {
                    if(!this.isPlaying) return;
                    let key = e.key.toUpperCase();
                    if(key === ' ') key = 'SPACE';
                    if(this.keys.has(key) && !this.pressed.has(key)) {
                        this.pressed.add(key);
                        this.handleHit(key);
                    }
                };
                window.onkeyup = (e) => {
                    let key = e.key.toUpperCase();
                    if(key === ' ') key = 'SPACE';
                    if(this.keys.has(key)) {
                        this.pressed.delete(key);
                        this.keys.get(key).classList.remove('active');
                    }
                };
            }

            start() {
                this.score = 0;
                this.combo = 1;
                this.startTime = Date.now();
                this.isPlaying = true;
                this.bugs.forEach(b => b.el.remove());
                this.bugs = [];
                this.overlay.style.display = 'none';
                this.updateUI();
                
                if(this.spawnInt) clearInterval(this.spawnInt);
                this.spawnInt = setInterval(() => this.spawnBug(), 600);
            }

            spawnBug() {
                if(!this.isPlaying) return;
                const el = document.createElement('div');
                el.className = 'bug';
                el.textContent = INSECTS[Math.floor(Math.random() * INSECTS.length)];
                
                const rect = this.kb.getBoundingClientRect();
                
                // SPAWN WELL OUTSIDE THE KEYBOARD
                const spawnMargin = 300;
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                
                if(edge === 0) { // Top
                    x = Math.random() * (rect.width + spawnMargin * 2) - spawnMargin;
                    y = -spawnMargin;
                } else if(edge === 1) { // Right
                    x = rect.width + spawnMargin;
                    y = Math.random() * (rect.height + spawnMargin * 2) - spawnMargin;
                } else if(edge === 2) { // Bottom
                    x = Math.random() * (rect.width + spawnMargin * 2) - spawnMargin;
                    y = rect.height + spawnMargin;
                } else { // Left
                    x = -spawnMargin;
                    y = Math.random() * (rect.height + spawnMargin * 2) - spawnMargin;
                }

                // Initial vector targets the center of the keyboard to guarantee crossing
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const angle = Math.atan2(centerY - y, centerX - x) + (Math.random() - 0.5) * 0.5;
                const speed = 3 + Math.random() * 4;

                this.kb.appendChild(el);
                this.bugs.push({
                    el, x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                });
            }

            handleHit(key) {
                const el = this.keys.get(key);
                el.classList.add('active');

                const kRect = el.getBoundingClientRect();
                let hitCount = 0;

                for(let i = this.bugs.length - 1; i >= 0; i--) {
                    const bug = this.bugs[i];
                    const bRect = bug.el.getBoundingClientRect();
                    
                    // Simple AABB overlap in viewport space
                    if (!(bRect.right < kRect.left || 
                          bRect.left > kRect.right || 
                          bRect.bottom < kRect.top || 
                          bRect.top > kRect.bottom)) {
                        this.killBug(bug, i);
                        hitCount++;
                    }
                }

                if(hitCount > 0) {
                    this.score += hitCount * this.combo;
                    this.combo++;
                    el.classList.add('hit');
                    setTimeout(() => el.classList.remove('hit'), 150);
                } else {
                    this.combo = 1;
                    el.classList.add('miss');
                    setTimeout(() => el.classList.remove('miss'), 150);
                }
                this.updateUI();
            }

            killBug(bug, idx) {
                const splat = document.createElement('div');
                splat.className = 'splat';
                splat.textContent = 'üí•';
                splat.style.left = bug.x + 'px';
                splat.style.top = bug.y + 'px';
                this.kb.appendChild(splat);
                setTimeout(() => splat.remove(), 600);
                bug.el.remove();
                this.bugs.splice(idx, 1);
            }

            overlap(r1, r2) {
                const pad = -10; 
                return !(r2.left > r1.right + pad || r2.right < r1.left - pad || r2.top > r1.bottom + pad || r2.bottom < r1.top - pad);
            }

            updateUI() {
                document.getElementById('score-val').textContent = this.score;
                document.getElementById('combo-val').textContent = `x${this.combo}`;
                if(this.score > this.best) {
                    this.best = this.score;
                    localStorage.setItem('keyfly-best', this.best);
                }
            }

            loop() {
                if(this.isPlaying) {
                    const rect = this.kb.getBoundingClientRect();
                    const boundary = 600; // Despawn boundary

                    for(let i = this.bugs.length - 1; i >= 0; i--) {
                        const bug = this.bugs[i];
                        
                        // Chaotic insect wiggle
                        bug.vx += (Math.random() - 0.5) * 0.5;
                        bug.vy += (Math.random() - 0.5) * 0.5;
                        
                        // Friction/Speed limit
                        bug.vx = Math.max(-8, Math.min(8, bug.vx));
                        bug.vy = Math.max(-8, Math.min(8, bug.vy));

                        bug.x += bug.vx;
                        bug.y += bug.vy;

                        // Despawn if too far out
                        if (bug.x < -boundary || bug.x > rect.width + boundary || 
                            bug.y < -boundary || bug.y > rect.height + boundary) {
                            bug.el.remove();
                            this.bugs.splice(i, 1);
                            continue;
                        }

                        // Physical hovering - translateZ keeps them physically closer to the viewer than the keys
                        bug.el.style.transform = `translate3d(${bug.x}px, ${bug.y}px, 150px)`;
                    }

                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const s = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('timer-val').textContent = `${m}:${s}`;
                }
                requestAnimationFrame(() => this.loop());
            }
        }

        window.game = new Game();
    </script>
</body>
</html>