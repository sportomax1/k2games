<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sled Master: Winter Sports - K2 games</title>
    <style>
        :root {
            --sky-top: #bae6fd;
            --sky-bottom: #f8fafc;
            --primary: #0ea5e9;
            --primary-dark: #0284c7;
            --accent: #f59e0b;
            --text: #0f172a;
            --glass: rgba(255, 255, 255, 0.85);
            --border: rgba(0, 0, 0, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; touch-action: none; }
        
        body {
            background-color: var(--sky-bottom);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 100;
        }

        /* Top Bar */
        #top-bar {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
        }

        .toolbar { display: flex; gap: 6px; padding: 5px; }

        .tool-btn {
            width: 42px; height: 42px;
            border: none; border-radius: 10px;
            background: transparent;
            font-size: 1.1rem; cursor: pointer;
            transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .tool-btn.active { background: white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); color: var(--primary); }

        /* Character Selection */
        #char-select {
            display: flex; gap: 8px; padding: 5px;
        }
        .char-btn {
            width: 42px; height: 42px; border: none; border-radius: 10px;
            background: transparent; font-size: 1.3rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: 0.2s;
        }
        .char-btn.active { background: white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transform: scale(1.1); }

        /* Stats HUD */
        #stats-hud {
            position: absolute; top: 85px; left: 20px;
            padding: 12px 18px; display: flex; flex-direction: column;
            gap: 6px; min-width: 130px;
        }
        .stat-line { display: flex; justify-content: space-between; font-size: 0.75rem; font-weight: 700; opacity: 0.7; }
        .stat-val { color: var(--primary); font-family: monospace; font-size: 1.1rem; font-weight: 800; }

        /* Mobile Controls */
        #mobile-controls { margin-top: auto; padding: 20px; display: flex; justify-content: space-between; align-items: flex-end; }
        .circle-btn { width: 54px; height: 54px; border-radius: 50%; border: 1px solid var(--border); background: var(--glass); backdrop-filter: blur(8px); font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        /* Overlays */
        .screen-overlay { position: absolute; inset: 0; background: rgba(15, 23, 42, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(10px); text-align: center; color: white; pointer-events: auto; }
        .btn-play { background: var(--primary); color: white; border: none; padding: 16px 45px; border-radius: 50px; font-weight: 800; cursor: pointer; font-size: 1.4rem; box-shadow: 0 10px 30px rgba(14, 165, 233, 0.4); }

        canvas { display: block; width: 100%; height: 100%; }
        #canvas-container { flex: 1; position: relative; background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom)); }

        .back-link { position: absolute; top: 20px; left: 20px; color: var(--text); text-decoration: none; font-weight: 800; font-size: 0.75rem; z-index: 200; opacity: 0.4; }
        .ink-bar { width: 100px; height: 5px; background: rgba(0,0,0,0.1); border-radius: 3px; overflow: hidden; margin-top: 4px; }
        #ink-fill { height: 100%; width: 100%; background: var(--primary); }

        @media (max-width: 700px) {
            #stats-hud { top: auto; bottom: 90px; left: 20px; }
            .back-link { top: 75px; left: 20px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"><canvas id="gameCanvas"></canvas></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div class="toolbar glass-panel">
                <button class="tool-btn active" id="tool-draw">‚úèÔ∏è</button>
                <button class="tool-btn" id="tool-erase">üßΩ</button>
                <div style="width: 1px; background: var(--border); margin: 8px 4px;"></div>
                <button class="tool-btn" id="tool-play">‚ñ∂Ô∏è</button>
                <button class="tool-btn" id="tool-reset">üîÑ</button>
            </div>

            <div class="glass-panel" id="char-select">
                <button class="char-btn" onclick="game.setChar('sled')" id="char-sled">üõ∑</button>
                <button class="char-btn active" onclick="game.setChar('ski')" id="char-ski">‚õ∑Ô∏è</button>
                <button class="char-btn" onclick="game.setChar('board')" id="char-board">üèÇ</button>
            </div>

            <div class="glass-panel" style="padding: 10px;">
                <div style="font-size: 0.5rem; text-transform: uppercase; font-weight: 900; opacity: 0.4;">Ink</div>
                <div class="ink-bar"><div id="ink-fill"></div></div>
            </div>
        </div>

        <div id="stats-hud" class="glass-panel">
            <div class="stat-line"><span>SPD</span><span id="speed-val" class="stat-val">0</span></div>
            <div class="stat-line"><span>DST</span><span id="dist-val" class="stat-val">0</span></div>
            <div class="stat-line"><span>AIR</span><span id="air-val" class="stat-val">0.0s</span></div>
        </div>

        <div id="mobile-controls">
            <div style="display:flex; gap:10px; pointer-events:auto">
                <button class="circle-btn" id="btn-zoom-out">‚ûñ</button>
                <button class="circle-btn" id="btn-zoom-in">‚ûï</button>
            </div>
            <button class="circle-btn" style="pointer-events:auto" id="btn-undo">‚Ü©Ô∏è</button>
        </div>

        <div id="overlay" class="screen-overlay" style="display:none">
            <h1 style="font-size: 4rem; margin-bottom: 5px; font-weight: 900;">WIPEOUT!</h1>
            <p style="margin-bottom: 30px; opacity: 0.7;">Time to fix the track.</p>
            <button class="btn-play" onclick="game.reset()">RESET RUN</button>
        </div>
    </div>

    <a href="index.html" class="back-link">‚Üê HUB</a>

    <script>
        class SledMaster {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();

                this.state = 'drawing';
                this.tool = 'draw';
                this.charType = 'ski';
                this.lines = [];
                this.currentLine = [];
                this.rider = { x: 100, y: 150, vx: 0, vy: 0, rot: 0, alive: true, airTime: 0 };
                this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
                this.inkMax = 10000;
                this.inkUsed = 0;
                this.mouse = { x: 0, y: 0, down: false };
                this.bgElements = [];

                this.init();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            init() {
                for(let i=0; i<20; i++) this.bgElements.push({ x: Math.random()*8000-1000, y: 200+Math.random()*500, scale: 0.4+Math.random()*1.6, parallax: 0.1+Math.random()*0.4, type: Math.random()>0.4?'peak':'cloud' });
                this.setupInputs();
                window.onresize = () => this.resize();
                requestAnimationFrame(() => this.loop());
            }

            setChar(type) {
                this.charType = type;
                document.querySelectorAll('.char-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('char-' + type).classList.add('active');
            }

            setupInputs() {
                const getP = (e) => {
                    const r = this.canvas.getBoundingClientRect();
                    const t = e.touches ? e.touches[0] : e;
                    return { x: (t.clientX - r.left)/this.camera.zoom + this.camera.x, y: (t.clientY - r.top)/this.camera.zoom + this.camera.y };
                };
                const down = (e) => {
                    const p = getP(e); this.mouse.down = true;
                    if(this.state === 'drawing') { if(this.tool === 'draw') this.currentLine = [p]; else this.eraseAt(p); }
                };
                const move = (e) => {
                    const p = getP(e);
                    if(this.mouse.down && this.state === 'drawing') {
                        if(this.tool === 'draw' && this.inkUsed < this.inkMax) {
                            const last = this.currentLine[this.currentLine.length-1];
                            const d = Math.hypot(p.x - last.x, p.y - last.y);
                            if(d > 6) { this.currentLine.push(p); this.inkUsed += d; this.updateUI(); }
                        } else if(this.tool === 'erase') this.eraseAt(p);
                    }
                };
                const up = () => { this.mouse.down = false; if(this.currentLine.length > 1) this.lines.push([...this.currentLine]); this.currentLine = []; };

                this.canvas.onmousedown = down; window.onmousemove = move; window.onmouseup = up;
                this.canvas.ontouchstart = (e) => { e.preventDefault(); down(e); };
                window.ontouchmove = (e) => { if(this.mouse.down) e.preventDefault(); move(e); };
                window.ontouchend = up;

                document.getElementById('tool-draw').onclick = () => this.setTool('draw');
                document.getElementById('tool-erase').onclick = () => this.setTool('erase');
                document.getElementById('tool-play').onclick = () => this.togglePlay();
                document.getElementById('tool-reset').onclick = () => this.resetAll();
                document.getElementById('btn-zoom-in').onclick = () => this.camera.targetZoom = Math.min(4, this.camera.targetZoom * 1.3);
                document.getElementById('btn-zoom-out').onclick = () => this.camera.targetZoom = Math.max(0.2, this.camera.targetZoom * 0.7);
                document.getElementById('btn-undo').onclick = () => { this.lines.pop(); this.updateUI(); };
            }

            setTool(t) { this.tool = t; document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); document.getElementById('tool-'+t).classList.add('active'); }

            togglePlay() {
                if(this.state === 'drawing') {
                    if(this.lines.length === 0) return;
                    this.state = 'playing';
                    this.rider = { x: 100, y: 150, vx: 2.0, vy: 0, rot: 0, alive: true, airTime: 0 };
                    // Snap camera immediately
                    this.camera.x = this.rider.x - this.canvas.width/(2*this.camera.zoom);
                    this.camera.y = this.rider.y - this.canvas.height/(2*this.camera.zoom);
                    document.getElementById('tool-play').textContent = '‚è∏Ô∏è';
                } else {
                    this.state = 'drawing';
                    this.camera.targetZoom = 1;
                    document.getElementById('tool-play').textContent = '‚ñ∂Ô∏è';
                }
            }

            resetAll() { 
                this.lines = []; 
                this.inkUsed = 0; 
                this.reset(); 
            }

            reset() { 
                this.state = 'drawing'; 
                this.camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 }; 
                this.rider = { x: 100, y: 150, vx: 0, vy: 0, rot: 0, alive: true, airTime: 0 };
                document.getElementById('overlay').style.display = 'none'; 
                document.getElementById('tool-play').textContent = '‚ñ∂Ô∏è'; 
                this.updateUI(); 
            }

            eraseAt(p) {
                const range = 50/this.camera.zoom;
                this.lines = this.lines.filter(l => {
                    const hit = l.some(pt => Math.hypot(pt.x-p.x, pt.y-p.y) < range);
                    if(hit) { 
                        let len=0; 
                        for(let i=0; i<l.length-1; i++) len+=Math.hypot(l[i].x-l[i+1].x, l[i].y-l[i+1].y); 
                        this.inkUsed = Math.max(0, this.inkUsed-len); 
                    }
                    return !hit;
                });
                this.updateUI();
            }

            update() {
                this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.1;
                
                if(this.state === 'playing' && this.rider.alive) {
                    const r = this.rider; 
                    r.vy += 0.35; // Gravity
                    r.vx *= 0.998; 
                    r.vy *= 0.998; 
                    r.x += r.vx; 
                    r.y += r.vy;

                    let hit = false;
                    for(let l of this.lines) {
                        for(let i=0; i<l.length-1; i++) {
                            const p1 = l[i], p2 = l[i+1];
                            const d = this.distToSegment(r, p1, p2);
                            
                            if(d < 25) { // Slightly larger hit box for stability
                                const ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
                                const s = Math.hypot(r.vx, r.vy);
                                
                                // Crash if angle difference is too steep
                                const angleDiff = Math.abs(this.normAng(ang - r.rot));
                                if(angleDiff > Math.PI/2.2 && s > 12) {
                                    this.crash();
                                    return;
                                }

                                r.rot = ang; 
                                r.vx = Math.cos(ang)*s + Math.cos(ang - Math.PI/2)*0.1; 
                                r.vy = Math.sin(ang)*s + Math.sin(ang - Math.PI/2)*0.1;
                                
                                // Stick to line
                                const pushX = Math.cos(ang - Math.PI/2) * (20 - d);
                                const pushY = Math.sin(ang - Math.PI/2) * (20 - d);
                                r.x += pushX;
                                r.y += pushY;

                                r.airTime = 0; 
                                hit = true; 
                                break;
                            }
                        }
                        if(hit) break;
                    }

                    if(!hit) { 
                        r.airTime += 1/60; 
                        r.rot += r.vx * 0.005; // Natural rotation in air
                    }

                    const tx = r.x - this.canvas.width/(2*this.camera.zoom);
                    const ty = r.y - this.canvas.height/(2*this.camera.zoom);
                    this.camera.x += (tx - this.camera.x) * 0.15;
                    this.camera.y += (ty - this.camera.y) * 0.15;

                    if(r.y > 10000) this.crash();
                    this.updateUI();
                }
            }

            crash() { this.rider.alive = false; document.getElementById('overlay').style.display = 'flex'; }
            normAng(a) { while(a < -Math.PI) a += Math.PI*2; while(a > Math.PI) a -= Math.PI*2; return a; }
            distToSegment(p, a, b) {
                const l2 = Math.hypot(a.x - b.x, a.y - b.y)**2; if (l2 === 0) return Math.hypot(p.x - a.x, p.y - a.y);
                let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return Math.hypot(p.x - (a.x + t * (b.x - a.x)), p.y - (a.y + t * (b.y - a.y)));
            }

            updateUI() {
                const s = Math.hypot(this.rider.vx, this.rider.vy);
                document.getElementById('speed-val').textContent = Math.floor(s*6);
                document.getElementById('dist-val').textContent = Math.floor(Math.max(0, (this.rider.x-100)/10));
                document.getElementById('air-val').textContent = this.rider.airTime.toFixed(1) + 's';
                document.getElementById('ink-fill').style.width = Math.max(0, (1 - this.inkUsed/this.inkMax)*100) + '%';
            }

            draw() {
                const ctx = this.ctx; ctx.clearRect(0,0,this.width,this.height);
                ctx.save(); ctx.scale(this.camera.zoom, this.camera.zoom); ctx.translate(-this.camera.x, -this.camera.y);

                // Parallax
                this.bgElements.forEach(el => {
                    const px = el.x + this.camera.x * el.parallax; ctx.globalAlpha = 0.2; ctx.fillStyle = el.type==='peak'?'#94a3b8':'#fff';
                    if(el.type==='peak') { ctx.beginPath(); ctx.moveTo(px, el.y); ctx.lineTo(px+120*el.scale, el.y+250*el.scale); ctx.lineTo(px-120*el.scale, el.y+250*el.scale); ctx.fill(); }
                    else { ctx.beginPath(); ctx.ellipse(px, el.y, 80*el.scale, 40*el.scale, 0, 0, Math.PI*2); ctx.fill(); }
                });
                ctx.globalAlpha = 1.0;

                // Course Start Indicator
                if(this.state === 'drawing') {
                    ctx.save(); ctx.translate(100, 150); ctx.globalAlpha = 0.3;
                    ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText({ski:'‚õ∑Ô∏è',sled:'üõ∑',board:'üèÇ'}[this.charType], 0, 0);
                    ctx.fillStyle = 'var(--accent)'; ctx.font = 'bold 12px Arial'; ctx.fillText('START LINE', 0, 20);
                    ctx.restore();
                }

                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                const dL = (l, shadow = true) => {
                    if(shadow) { ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth = 12; ctx.beginPath(); ctx.moveTo(l[0].x, l[0].y+12); for(let i=1; i<l.length; i++) ctx.lineTo(l[i].x, l[i].y+12); ctx.stroke(); }
                    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 7; ctx.beginPath(); ctx.moveTo(l[0].x, l[0].y); for(let i=1; i<l.length; i++) ctx.lineTo(l[i].x, l[i].y); ctx.stroke();
                };
                this.lines.forEach(l => dL(l));
                if(this.currentLine.length > 1) { ctx.strokeStyle = this.tool==='draw'?'var(--primary)':'#f43f5e'; dL(this.currentLine, false); }

                if(this.rider.alive && this.state === 'playing') {
                    ctx.save(); ctx.translate(this.rider.x, this.rider.y); ctx.rotate(this.rider.rot);
                    ctx.font = '36px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.scale(this.rider.vx < 0 ? -1 : 1, 1);
                    ctx.fillText({ski:'‚õ∑Ô∏è',sled:'üõ∑',board:'üèÇ'}[this.charType], 0, 6);
                    ctx.restore();
                }
                ctx.restore();
            }

            loop() { this.update(); this.draw(); requestAnimationFrame(() => this.loop()); }
        }
        const game = new SledMaster();
    </script>
</body>
</html>
