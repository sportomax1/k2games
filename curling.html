<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Curling: Ice Strategy - K2 games</title>
    <style>
        :root {
            --ice: #f0f9ff;
            --house-red: #ef4444;
            --house-blue: #3b82f6;
            --stone-handle: #fbbf24;
            --stone-body: #94a3b8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        
        body {
            background-color: #0f172a;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #game-view {
            flex: 1;
            position: relative;
            background: #cbd5e1;
            display: flex;
            justify-content: center;
        }

        canvas { display: block; max-width: 100%; height: 100%; box-shadow: 0 0 50px rgba(0,0,0,0.5); }

        #ui {
            position: absolute; top: 20px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; pointer-events: none;
        }

        .score-box {
            background: rgba(0,0,0,0.7);
            padding: 10px 20px; border-radius: 12px;
            text-align: center; border: 2px solid white;
        }
        .score-val { font-size: 2rem; font-weight: 900; }
        .score-label { font-size: 0.7rem; opacity: 0.7; }

        .back-link {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #64748b; font-weight: bold; text-decoration: none;
        }

        #controls {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; gap: 20px;
            pointer-events: none;
        }

        .sweep-btn {
            width: 80px; height: 80px; border-radius: 50%;
            background: rgba(255,255,255,0.2); border: 2px solid white;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; pointer-events: auto; cursor: pointer;
            backdrop-filter: blur(5px); transition: 0.1s;
        }
        .sweep-btn:active { background: rgba(255,255,255,0.5); transform: scale(0.95); }

        #power-meter {
            position: absolute; bottom: 150px; right: 30px;
            width: 20px; height: 200px; background: rgba(0,0,0,0.5);
            border-radius: 10px; overflow: hidden; border: 2px solid white;
        }
        #power-fill { width: 100%; bottom: 0; position: absolute; background: linear-gradient(to top, #22c55e, #ef4444); }

        #overlay {
            position: absolute; inset: 0; background: rgba(15, 23, 42, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        .btn-start {
            padding: 15px 40px; font-size: 1.2rem; font-weight: 900;
            background: #3b82f6; color: white; border: none; border-radius: 50px; cursor: pointer;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê HUB</a>

    <div id="game-view">
        <canvas id="iceCanvas"></canvas>
        
        <div id="ui">
            <div class="score-box" style="border-color: #ef4444">
                <div class="score-label">RED</div>
                <div id="score-red" class="score-val">0</div>
            </div>
            <div class="score-box" style="border-color: #fbbf24">
                <div class="score-label">END</div>
                <div id="end-val" class="score-val">1</div>
            </div>
            <div class="score-box" style="border-color: #3b82f6">
                <div class="score-label">BLUE</div>
                <div id="score-blue" class="score-val">0</div>
            </div>
        </div>

        <div id="power-meter"><div id="power-fill" style="height: 0%"></div></div>

        <div id="controls">
            <div class="sweep-btn" id="btn-sweep">üßπ</div>
        </div>

        <div id="overlay">
            <h1 style="font-size: 3rem; margin-bottom: 10px;">CURLING</h1>
            <p style="margin-bottom: 30px; opacity: 0.7;">Drag to Aim ‚Ä¢ Hold to Power ‚Ä¢ Tap to Sweep</p>
            <button class="btn-start" onclick="startGame()">START MATCH</button>
        </div>
    </div>

    <script>
        class Curling {
            constructor() {
                this.canvas = document.getElementById('iceCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 600; 
                this.height = 1000;
                this.resize();

                this.stones = [];
                this.currentStone = null;
                this.turn = 'red'; // red, blue
                this.state = 'aiming'; // aiming, powering, sliding, sweeping, idle
                this.power = 0;
                this.powerDir = 1;
                this.aimAngle = 0;
                this.friction = 0.985;
                
                this.end = 1;
                this.shotsLeft = 8;
                this.scores = { red: 0, blue: 0 };

                this.setupInput();
                this.loop();
            }

            resize() {
                // Fixed aspect ratio rendering
                const aspect = 0.6; 
                const winW = window.innerWidth;
                const winH = window.innerHeight;
                
                if (winW / winH < aspect) {
                    this.canvas.width = winW;
                    this.canvas.height = winW / aspect;
                } else {
                    this.canvas.height = winH;
                    this.canvas.width = winH * aspect;
                }
                this.scale = this.canvas.width / 600;
            }

            setupInput() {
                window.addEventListener('resize', () => this.resize());
                
                const handleStart = (e) => {
                    if (this.state === 'aiming') {
                        this.state = 'powering';
                    } else if (this.state === 'powering') {
                        this.throwStone();
                    } else if (this.state === 'sliding') {
                        // Sweep reduces friction
                        this.friction = 0.992;
                        // Particle effect
                        this.spawnParticles(this.currentStone.x, this.currentStone.y);
                    }
                };

                const handleEnd = () => {
                    if(this.state === 'sliding') this.friction = 0.985; // Reset friction
                };

                this.canvas.addEventListener('mousedown', handleStart);
                this.canvas.addEventListener('mouseup', handleEnd);
                this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); });
                this.canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleEnd(); });
                
                document.getElementById('btn-sweep').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(this.state === 'sliding') this.friction = 0.995;
                });
                document.getElementById('btn-sweep').addEventListener('touchend', () => {
                    if(this.state === 'sliding') this.friction = 0.985;
                });

                window.addEventListener('mousemove', (e) => {
                    if(this.state === 'aiming') {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = (e.clientX - rect.left) / this.scale;
                        this.aimAngle = (x - 300) * 0.002;
                    }
                });
            }

            throwStone() {
                this.state = 'sliding';
                this.currentStone = {
                    x: 300, y: 900,
                    vx: Math.sin(this.aimAngle) * (this.power * 0.2),
                    vy: -Math.cos(this.aimAngle) * (this.power * 0.2),
                    r: 25, color: this.turn === 'red' ? '#ef4444' : '#3b82f6',
                    stopped: false
                };
                this.stones.push(this.currentStone);
                this.power = 0;
                document.getElementById('power-fill').style.height = '0%';
            }

            update() {
                if (this.state === 'powering') {
                    this.power += 2 * this.powerDir;
                    if (this.power >= 100 || this.power <= 0) this.powerDir *= -1;
                    document.getElementById('power-fill').style.height = this.power + '%';
                }

                if (this.state === 'sliding') {
                    // Move all moving stones
                    let moving = false;
                    this.stones.forEach(s => {
                        if (Math.abs(s.vx) > 0.05 || Math.abs(s.vy) > 0.05) {
                            moving = true;
                            s.x += s.vx;
                            s.y += s.vy;
                            s.vx *= this.friction;
                            s.vy *= this.friction;

                            // Wall bounce
                            if (s.x < 25 || s.x > 575) s.vx *= -0.8;
                            if (s.y < 25 || s.y > 975) s.vy *= -0.8;

                            // Collision
                            this.stones.forEach(other => {
                                if (s !== other) {
                                    const dx = other.x - s.x;
                                    const dy = other.y - s.y;
                                    const dist = Math.hypot(dx, dy);
                                    if (dist < 50) {
                                        // Simple elastic collision
                                        const angle = Math.atan2(dy, dx);
                                        const v1 = Math.hypot(s.vx, s.vy);
                                        const v2 = Math.hypot(other.vx, other.vy);
                                        
                                        s.vx = -Math.cos(angle) * v2 * 0.8;
                                        s.vy = -Math.sin(angle) * v2 * 0.8;
                                        other.vx = Math.cos(angle) * v1 * 0.8;
                                        other.vy = Math.sin(angle) * v1 * 0.8;
                                        
                                        // Separation
                                        const overlap = 50 - dist;
                                        s.x -= Math.cos(angle) * overlap/2;
                                        s.y -= Math.sin(angle) * overlap/2;
                                        other.x += Math.cos(angle) * overlap/2;
                                        other.y += Math.sin(angle) * overlap/2;
                                    }
                                }
                            });
                        } else {
                            s.vx = 0; s.vy = 0;
                        }
                    });

                    if (!moving) {
                        this.nextTurn();
                    }
                }
            }

            nextTurn() {
                this.state = 'aiming';
                this.shotsLeft--;
                this.turn = this.turn === 'red' ? 'blue' : 'red';
                
                if (this.shotsLeft <= 0) {
                    this.scoreEnd();
                }
            }

            scoreEnd() {
                // Calculate score
                const center = { x: 300, y: 200 };
                // Find closest stone
                let closestDist = 9999;
                let closestColor = null;
                
                this.stones.forEach(s => {
                    const d = Math.hypot(s.x - center.x, s.y - center.y);
                    if (d < closestDist) {
                        closestDist = d;
                        closestColor = s.color === '#ef4444' ? 'red' : 'blue';
                    }
                });

                if (closestColor) {
                    let points = 0;
                    // Count stones of that color closer than opponent's best
                    // Simplified: just give 1 point for closest
                    this.scores[closestColor]++;
                    document.getElementById(`score-${closestColor}`).textContent = this.scores[closestColor];
                }

                this.stones = []; // Clear board for next end
                this.shotsLeft = 8;
                this.end++;
                document.getElementById('end-val').textContent = this.end;
                
                if (this.end > 4) {
                    alert(`GAME OVER! ${this.scores.red > this.scores.blue ? 'RED' : 'BLUE'} WINS!`);
                    location.reload();
                }
            }

            spawnParticles(x, y) {
                // Visual effect for sweeping
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.save();
                ctx.scale(this.scale, this.scale);

                // Ice
                ctx.fillStyle = '#f0f9ff';
                ctx.fillRect(0, 0, 600, 1000);

                // House (Target)
                const drawCircle = (r, c) => {
                    ctx.beginPath(); ctx.arc(300, 200, r, 0, Math.PI*2);
                    ctx.fillStyle = c; ctx.fill();
                };
                drawCircle(180, '#3b82f6');
                drawCircle(120, '#fff');
                drawCircle(60, '#ef4444');
                drawCircle(20, '#fff');

                // Lines
                ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(300, 0); ctx.lineTo(300, 1000); ctx.stroke(); // Center line
                ctx.beginPath(); ctx.moveTo(0, 200); ctx.lineTo(600, 200); ctx.stroke(); // Tee line
                ctx.beginPath(); ctx.moveTo(0, 800); ctx.lineTo(600, 800); ctx.stroke(); // Hog line

                // Aim Line
                if (this.state === 'aiming' || this.state === 'powering') {
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath(); ctx.moveTo(300, 900);
                    ctx.lineTo(300 + Math.sin(this.aimAngle)*800, 900 - Math.cos(this.aimAngle)*800);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Stones
                this.stones.forEach(s => {
                    ctx.fillStyle = s.color;
                    ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Handle
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath(); ctx.roundRect(s.x-10, s.y-15, 20, 30, 5); ctx.fill();
                });

                // Current Stone (Ghost if aiming)
                if (this.state === 'aiming' || this.state === 'powering') {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = this.turn === 'red' ? '#ef4444' : '#3b82f6';
                    ctx.beginPath(); ctx.arc(300, 900, 25, 0, Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1.0;
                }

                ctx.restore();
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        let game = new Curling();
        function startGame() {
            document.getElementById('overlay').style.display = 'none';
        }
    </script>
</body>
</html>
