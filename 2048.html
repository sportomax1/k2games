<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048: Neon Edition - K2 games</title>
    <style>
        :root {
            --bg: #0f172a;
            --grid-bg: #1e293b;
            --cell-bg: #334155;
            --text: #f8fafc;
            --accent: #38bdf8;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #game-container {
            width: 450px;
            padding: 20px;
            background: var(--grid-bg);
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .header {
            width: 450px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 20px;
        }

        .title { font-size: 4rem; font-weight: 900; color: var(--accent); line-height: 1; }
        
        .score-container {
            background: var(--grid-bg);
            padding: 10px 20px;
            border-radius: 6px;
            text-align: center;
            min-width: 100px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .score-label { font-size: 0.7rem; text-transform: uppercase; opacity: 0.6; }
        .score-value { font-size: 1.5rem; font-weight: 800; }

        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 15px;
            background: var(--bg);
            padding: 15px;
            border-radius: 8px;
            aspect-ratio: 1;
        }

        .cell {
            background: var(--cell-bg);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 800;
            transition: all 0.1s ease-in-out;
            position: relative;
        }

        /* Tile Colors */
        .tile-2 { background: #cbd5e1; color: #1e293b; }
        .tile-4 { background: #94a3b8; color: #1e293b; }
        .tile-8 { background: #38bdf8; color: white; box-shadow: 0 0 15px #38bdf8; }
        .tile-16 { background: #0ea5e9; color: white; box-shadow: 0 0 15px #0ea5e9; }
        .tile-32 { background: #0284c7; color: white; box-shadow: 0 0 15px #0284c7; }
        .tile-64 { background: #f43f5e; color: white; box-shadow: 0 0 15px #f43f5e; }
        .tile-128 { background: #e11d48; color: white; box-shadow: 0 0 20px #e11d48; font-size: 1.8rem; }
        .tile-256 { background: #fbbf24; color: #1e293b; box-shadow: 0 0 25px #fbbf24; font-size: 1.8rem; }
        .tile-512 { background: #f59e0b; color: #1e293b; box-shadow: 0 0 30px #f59e0b; font-size: 1.8rem; }
        .tile-1024 { background: #10b981; color: white; box-shadow: 0 0 35px #10b981; font-size: 1.5rem; }
        .tile-2048 { background: #059669; color: white; box-shadow: 0 0 40px #059669; font-size: 1.5rem; }

        .back-link {
            position: fixed; top: 20px; left: 20px; color: white; text-decoration: none;
            background: rgba(255,255,255,0.1); padding: 10px 20px; border-radius: 12px; z-index: 100;
            font-weight: bold; border: 1px solid rgba(255,255,255,0.1);
        }

        #overlay {
            position: absolute; inset: 0; background: rgba(15, 23, 42, 0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; border-radius: 12px; backdrop-filter: blur(4px);
        }

        .btn {
            background: var(--accent); color: var(--bg); border: none; padding: 12px 30px;
            border-radius: 50px; font-weight: 800; cursor: pointer; margin-top: 20px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← HUB</a>

    <div class="header">
        <div class="title">2048</div>
        <div style="display: flex; gap: 10px;">
            <div class="score-container">
                <div class="score-label">Score</div>
                <div id="score" class="score-value">0</div>
            </div>
            <div class="score-container">
                <div class="score-label">Best</div>
                <div id="best" class="score-value">0</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <div class="grid" id="grid"></div>
        <div id="overlay">
            <h1 id="overlay-title" style="font-size: 3rem;">GAME OVER</h1>
            <button class="btn" onclick="game.init()">Try Again</button>
        </div>
    </div>

    <div style="margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; max-width: 450px; text-align: center;">
        <div style="opacity: 0.8; font-weight: bold; color: var(--accent);">HOW TO PLAY</div>
        <p style="opacity: 0.6; font-size: 0.85rem; line-height: 1.4;">
            Swipe or use arrow keys to move all tiles. When two tiles with the same number touch, they <b>merge into one!</b> Combine tiles to reach the ultimate <b>2048</b> block.
        </p>
        <div style="opacity: 0.4; font-size: 0.75rem; margin-top: 5px;">
            ARROW KEYS or WASD • TOUCH SWIPE SUPPORTED
        </div>
    </div>

    <script>
        class Game2048 {
            constructor() {
                this.gridEl = document.getElementById('grid');
                this.scoreEl = document.getElementById('score');
                this.bestEl = document.getElementById('best');
                this.overlay = document.getElementById('overlay');
                
                this.size = 4;
                this.grid = [];
                this.score = 0;
                this.best = parseInt(localStorage.getItem('2048-best') || 0);
                this.bestEl.textContent = this.best;

                this.setupInput();
                this.init();
            }

            init() {
                this.grid = Array(this.size * this.size).fill(0);
                this.score = 0;
                this.scoreEl.textContent = 0;
                this.overlay.style.display = 'none';
                this.addTile();
                this.addTile();
                this.render();
            }

            addTile() {
                const empty = this.grid.map((v, i) => v === 0 ? i : null).filter(v => v !== null);
                if (empty.length > 0) {
                    const idx = empty[Math.floor(Math.random() * empty.length)];
                    this.grid[idx] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            render() {
                this.gridEl.innerHTML = '';
                this.grid.forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'cell' + (val ? ` tile-${val}` : '');
                    cell.textContent = val || '';
                    this.gridEl.appendChild(cell);
                });
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    let moved = false;
                    if (e.key === 'ArrowUp' || e.key === 'w') moved = this.move('up');
                    if (e.key === 'ArrowDown' || e.key === 's') moved = this.move('down');
                    if (e.key === 'ArrowLeft' || e.key === 'a') moved = this.move('left');
                    if (e.key === 'ArrowRight' || e.key === 'd') moved = this.move('right');

                    if (moved) {
                        this.addTile();
                        this.render();
                        if (this.isGameOver()) this.showGameOver();
                    }
                });
            }

            move(dir) {
                let moved = false;
                const rows = [];
                
                for (let i = 0; i < this.size; i++) {
                    const line = [];
                    for (let j = 0; j < this.size; j++) {
                        let idx;
                        if (dir === 'left' || dir === 'right') idx = i * this.size + j;
                        else idx = j * this.size + i;
                        line.push(this.grid[idx]);
                    }
                    
                    if (dir === 'right' || dir === 'down') line.reverse();
                    
                    const newLine = this.compress(line);
                    if (JSON.stringify(line) !== JSON.stringify(newLine)) moved = true;
                    
                    if (dir === 'right' || dir === 'down') newLine.reverse();
                    rows.push(newLine);
                }

                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        let idx;
                        if (dir === 'left' || dir === 'right') {
                            idx = i * this.size + j;
                            this.grid[idx] = rows[i][j];
                        } else {
                            idx = j * this.size + i;
                            this.grid[idx] = rows[i][j];
                        }
                    }
                }

                return moved;
            }

            compress(line) {
                let nums = line.filter(v => v !== 0);
                for (let i = 0; i < nums.length - 1; i++) {
                    if (nums[i] === nums[i+1]) {
                        nums[i] *= 2;
                        this.score += nums[i];
                        nums.splice(i+1, 1);
                        if (this.score > this.best) {
                            this.best = this.score;
                            this.bestEl.textContent = this.best;
                            localStorage.setItem('2048-best', this.best);
                        }
                        this.scoreEl.textContent = this.score;
                    }
                }
                while (nums.length < this.size) nums.push(0);
                return nums;
            }

            isGameOver() {
                if (this.grid.includes(0)) return false;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size - 1; j++) {
                        // Check horizontal
                        if (this.grid[i * this.size + j] === this.grid[i * this.size + j + 1]) return false;
                        // Check vertical
                        if (this.grid[j * this.size + i] === this.grid[(j + 1) * this.size + i]) return false;
                    }
                }
                return true;
            }

            showGameOver() {
                this.overlay.style.display = 'flex';
            }
        }

        const game = new Game2048();
    </script>
</body>
</html>
