<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MiniCraft Elite - K2 games</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; font-family: 'Segoe UI', sans-serif; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.8); font-size: 24px; pointer-events: none;
            z-index: 10;
        }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: white; text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        #inventory {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 12px;
        }
        .inv-slot {
            width: 50px; height: 50px; border: 3px solid #666;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; color: white; border-radius: 8px; cursor: pointer;
            background-size: cover;
        }
        .inv-slot.active { border-color: #fbbf24; background-color: rgba(255,255,255,0.2); }
        
        #mobile-controls {
            position: absolute; bottom: 20px; right: 20px;
            display: none; flex-direction: column; gap: 10px;
        }
        .btn {
            width: 70px; height: 70px; background: rgba(0,0,0,0.5);
            border: 2px solid white; border-radius: 15px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: 900; font-size: 14px; cursor: pointer;
        }
        
        .back-link {
            position: fixed; top: 20px; right: 20px; color: white; text-decoration: none;
            background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 12px; z-index: 100;
            font-weight: bold; backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>

<a href="index.html" class="back-link">← HUB</a>
<div id="crosshair">+</div>
<div id="ui">
    <h2 style="margin:0">MiniCraft Elite</h2>
    <p style="font-size:0.8rem; opacity:0.8">WASD: Move • SPACE: Jump • LEFT CLICK: Mine • RIGHT CLICK: Build • 1-3: Items</p>
</div>

<div id="inventory">
    <div class="inv-slot active" id="slot-1" data-id="0" style="background-color:#4a7c3a">1</div>
    <div class="inv-slot" id="slot-2" data-id="1" style="background-color:#7b5c3d">2</div>
    <div class="inv-slot" id="slot-3" data-id="2" style="background-color:#808080">3</div>
</div>

<div id="mobile-controls">
    <div class="btn" id="btn-jump">JUMP</div>
    <div class="btn" id="btn-mine" style="background:rgba(239,68,68,0.5)">MINE</div>
    <div class="btn" id="btn-build" style="background:rgba(34,197,94,0.5)">BUILD</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let camera, scene, renderer;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let blocks = [];
    let selectedBlockType = 0; // 0: Grass, 1: Dirt, 2: Stone

    const worldSize = 24;
    const blockSize = 1;

    // Materials
    const materials = [
        new THREE.MeshLambertMaterial({ color: 0x4a7c3a }), // Grass
        new THREE.MeshLambertMaterial({ color: 0x7b5c3d }), // Dirt
        new THREE.MeshLambertMaterial({ color: 0x808080 })  // Stone
    ];
    const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 40);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(worldSize/2, 5, worldSize/2);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);

        // Click to Lock
        document.body.addEventListener('mousedown', () => {
            if (document.pointerLockElement !== document.body) document.body.requestPointerLock();
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        // Terrain Generation
        for (let x = 0; x < worldSize; x++) {
            for (let z = 0; z < worldSize; z++) {
                // Procedural height
                const h = Math.floor(Math.sin(x/4) * Math.cos(z/4) * 2) + 2;
                for (let y = 0; y <= h; y++) {
                    const type = y === h ? 0 : (y > h-2 ? 1 : 2);
                    addBlock(x, y, z, type);
                }
            }
        }

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);

        // Mine/Build Logic
        document.addEventListener('mousedown', (e) => {
            if (document.pointerLockElement !== document.body) return;
            handleAction(e.button === 0 ? 'mine' : 'build');
        });

        // Inventory Switching
        document.addEventListener('keydown', (e) => {
            if(e.key === '1') selectSlot(0);
            if(e.key === '2') selectSlot(1);
            if(e.key === '3') selectSlot(2);
        });
        
        window.oncontextmenu = () => false;

        // Mobile Setup
        if ('ontouchstart' in window) {
            document.getElementById('mobile-controls').style.display = 'flex';
            document.getElementById('btn-jump').ontouchstart = () => { if(canJump) velocity.y += 0.25; };
            document.getElementById('btn-mine').ontouchstart = () => handleAction('mine');
            document.getElementById('btn-build').ontouchstart = () => handleAction('build');
        }
    }

    function addBlock(x, y, z, type) {
        const block = new THREE.Mesh(geometry, materials[type]);
        block.position.set(x, y, z);
        block.userData.type = type;
        scene.add(block);
        blocks.push(block);
    }

    function handleAction(type) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({x: 0, y: 0}, camera);
        const intersects = raycaster.intersectObjects(blocks);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            if (type === 'mine') {
                scene.remove(intersect.object);
                blocks = blocks.filter(b => b !== intersect.object);
            } else {
                const pos = intersect.object.position.clone().add(intersect.face.normal);
                // Simple collision check with player
                const d = pos.distanceTo(camera.position);
                if(d > 0.8) addBlock(pos.x, pos.y, pos.z, selectedBlockType);
            }
        }
    }

    function selectSlot(idx) {
        selectedBlockType = idx;
        document.querySelectorAll('.inv-slot').forEach((s, i) => {
            s.classList.toggle('active', i === idx);
        });
    }

    function onKeyDown(event) {
        switch (event.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': if (canJump) velocity.y += 0.22; canJump = false; break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyD': moveRight = false; break;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const delta = 0.1;
        velocity.x -= velocity.x * 10.0 * delta * 0.1;
        velocity.z -= velocity.z * 10.0 * delta * 0.1;
        velocity.y -= 0.5 * delta * 0.15; 

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * 1.5 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 1.5 * delta;

        camera.translateX(-velocity.x);
        camera.translateZ(velocity.z);
        camera.position.y += velocity.y;

        // Ground check
        if (camera.position.y < 2) {
            velocity.y = 0;
            camera.position.y = 2;
            canJump = true;
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>