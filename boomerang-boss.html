<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Boomerang Boss: Arena Evolution - K2 games</title>
    <style>
        :root {
            --primary: #ff4757;
            --secondary: #2f3542;
            --accent: #ffa502;
            --bg: #1e1e2e;
            --arena: #f1f2f6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            background: var(--bg);
            color: white;
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            height: 100%;
            max-height: 700px;
            background: #2f3542;
            border-radius: 16px;
            border: 4px solid #3e4444;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: var(--arena);
        }

        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .score-board {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 12px;
            display: flex;
            gap: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .player-score {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .back-btn {
            background: var(--primary);
            color: white;
            text-decoration: none;
            padding: 10px 25px;
            border-radius: 50px;
            font-weight: 900;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }
        .back-btn:hover { transform: scale(1.05); filter: brightness(1.1); }

        #desktop-hints {
            position: absolute;
            top: 80px;
            left: 20px;
            font-size: 0.7rem;
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 8px;
            color: rgba(255,255,255,0.6);
            line-height: 1.4;
        }

        @media (max-width: 768px) { #desktop-hints { display: none; } }

        /* Mobile Controls */
        #mobile-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: var(--primary);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .action-btn {
            width: 70px; height: 70px;
            background: rgba(0,0,0,0.6);
            border: 3px solid var(--primary);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem; color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .action-btn:active { transform: scale(0.9); background: var(--primary); }

        /* Modals */
        #modal-overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #2f3542;
            padding: 30px; border-radius: 20px;
            text-align: center; max-width: 600px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 30px rgba(255, 71, 87, 0.3);
            max-height: 90vh; overflow-y: auto;
        }

        h1 { font-size: 2.5rem; margin-bottom: 10px; color: var(--primary); }
        
        .char-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px; margin-bottom: 20px;
        }

        .char-option {
            background: #4b5563; padding: 10px; border-radius: 12px;
            cursor: pointer; font-size: 1.8rem;
            border: 2px solid transparent; transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        .char-option.selected { border-color: var(--accent); background: #f8fafc; transform: scale(1.1); }

        .start-btn {
            background: var(--primary); color: white; border: none;
            padding: 15px 50px; font-size: 1.4rem; font-weight: 900;
            border-radius: 50px; cursor: pointer; text-transform: uppercase;
        }

        @media (max-width: 768px) {
            #mobile-ui { display: flex; }
            .char-grid { grid-template-columns: repeat(4, 1fr); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div class="header">
                <a href="index.html" class="back-btn">‚Üê HUB</a>
                <div id="score-board" class="score-board"></div>
            </div>
            <div id="desktop-hints">
                <b>WASD:</b> Move<br>
                <b>SPACE:</b> Throw Boomerang<br>
                <b>X:</b> Stab / Melee
            </div>
        </div>

        <div id="mobile-ui">
            <div class="joystick-container" id="joystick">
                <div class="joystick-knob" id="knob"></div>
            </div>
            <div class="action-buttons">
                <div class="action-btn" id="btn-stab">üî™</div>
                <div class="action-btn" id="btn-throw">ü™É</div>
            </div>
        </div>

        <div id="modal-overlay">
            <div class="modal-content">
                <h1>BOOMERANG BOSS</h1>
                <p style="margin-bottom: 20px; opacity: 0.7;">Select your character. Arena is chosen randomly!</p>
                <div class="char-grid" id="char-grid"></div>
                <button class="start-btn" onclick="startGame()">Battle!</button>
            </div>
        </div>
    </div>

    <script>
        const CHARACTERS = [
            { emoji: 'üçå', name: 'Banana' }, { emoji: 'üçû', name: 'Bread' },
            { emoji: 'ü•ë', name: 'Avocado' }, { emoji: 'üç©', name: 'Donut' },
            { emoji: 'üçÜ', name: 'Eggplant' }, { emoji: 'ü•ï', name: 'Carrot' },
            { emoji: 'üç£', name: 'Sushi' }, { emoji: 'üçî', name: 'Burger' }
        ];

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 1000;
                this.height = 700;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.players = [];
                this.boomerangs = [];
                this.obstacles = [];
                this.portals = [];
                this.keys = {};
                this.isPlaying = false;
                this.selectedCharIdx = 0;

                // Virtual Joystick
                this.joystick = { active: false, x: 0, y: 0 };
                this.particles = [];

                this.initMenu();
                this.setupControls();
                
                // Fixed loop call
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            initMenu() {
                const charGrid = document.getElementById('char-grid');
                CHARACTERS.forEach((char, i) => {
                    const div = document.createElement('div');
                    div.className = `char-option ${i === 0 ? 'selected' : ''}`;
                    div.textContent = char.emoji;
                    div.onclick = () => {
                        document.querySelectorAll('.char-option').forEach(el => el.classList.remove('selected'));
                        div.classList.add('selected');
                        this.selectedCharIdx = i;
                    };
                    charGrid.appendChild(div);
                });
            }

            setupControls() {
                window.onkeydown = (e) => this.keys[e.key] = true;
                window.onkeyup = (e) => this.keys[e.key] = false;

                const joy = document.getElementById('joystick');
                const knob = document.getElementById('knob');
                
                const handleJoy = (e) => {
                    if (!this.joystick.active) return;
                    const rect = joy.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    let dx = clientX - (rect.left + rect.width / 2);
                    let dy = clientY - (rect.top + rect.height / 2);
                    const dist = Math.min(60, Math.hypot(dx, dy));
                    const angle = Math.atan2(dy, dx);
                    
                    this.joystick.x = (Math.cos(angle) * dist) / 60;
                    this.joystick.y = (Math.sin(angle) * dist) / 60;
                    
                    knob.style.transform = `translate(calc(-50% + ${Math.cos(angle) * dist}px), calc(-50% + ${Math.sin(angle) * dist}px))`;
                };

                joy.addEventListener('touchstart', (e) => { this.joystick.active = true; handleJoy(e); });
                window.addEventListener('touchmove', (e) => handleJoy(e));
                window.addEventListener('touchend', () => {
                    this.joystick.active = false; this.joystick.x = this.joystick.y = 0;
                    knob.style.transform = 'translate(-50%, -50%)';
                });

                document.getElementById('btn-throw').onclick = () => this.isPlaying && this.throw(this.players[0]);
                document.getElementById('btn-stab').onclick = () => this.isPlaying && this.stab(this.players[0]);
            }

            start() {
                this.players = [];
                this.boomerangs = [];
                const maps = ['pillars', 'arena', 'cross', 'zig'];
                const randomMap = maps[Math.floor(Math.random() * maps.length)];
                this.obstacles = this.generateObstacles(randomMap);
                this.portals = this.generatePortals();
                
                this.players.push(this.createPlayer(100, 100, CHARACTERS[this.selectedCharIdx], false));
                const spawns = [{x: 900, y: 100}, {x: 100, y: 600}, {x: 900, y: 600}];
                spawns.forEach(s => {
                    const char = CHARACTERS[Math.floor(Math.random()*CHARACTERS.length)];
                    this.players.push(this.createPlayer(s.x, s.y, char, true));
                });

                this.isPlaying = true;
                document.getElementById('modal-overlay').style.display = 'none';
                this.updateScoreBoard();
            }

            createPlayer(x, y, char, isAI) {
                return { x, y, r: 25, vx: 0, vy: 0, char, isAI, alive: true, score: 0, cooldown: 0, lastDir: {x: isAI ? -1 : 1, y: 0}, stabTimer: 0, portalCooldown: 0 };
            }

            generateObstacles(type) {
                const obs = [];
                const colors = ['#ff9f43', '#ee5253', '#10ac84', '#5f27cd'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                if (type === 'pillars') {
                    for (let x = 250; x <= 750; x += 250) for (let y = 200; y <= 500; y += 300) obs.push({ x: x - 40, y: y - 40, w: 80, h: 80, color });
                } else if (type === 'arena') {
                    obs.push({ x: 400, y: 250, w: 200, h: 200, color });
                } else if (type === 'cross') {
                    obs.push({ x: 450, y: 50, w: 100, h: 250, color }, { x: 450, y: 400, w: 100, h: 250, color }, { x: 50, y: 300, w: 250, h: 100, color }, { x: 700, y: 300, w: 250, h: 100, color });
                } else if (type === 'zig') {
                    obs.push({ x: 200, y: 100, w: 600, h: 40, color }, { x: 200, y: 560, w: 600, h: 40, color }, { x: 480, y: 200, w: 40, h: 300, color });
                }
                return obs;
            }

            generatePortals() {
                return [
                    { x1: 100, y1: 350, x2: 900, y2: 350, r: 35, color: '#341f97' },
                    { x1: 500, y1: 100, x2: 500, y2: 600, r: 35, color: '#01a3a4' }
                ];
            }

            updateScoreBoard() {
                const board = document.getElementById('score-board');
                board.innerHTML = this.players.map(p => `<div class="player-score" style="opacity: ${p.alive ? 1 : 0.5}">${p.char.emoji} ${p.score}</div>`).join('');
            }

            update() {
                if(!this.isPlaying) return;

                this.players.forEach(p => {
                    if(!p.alive) return;
                    if(p.isAI) this.handleAI(p); else this.handleInput(p);

                    let nextX = p.x + p.vx;
                    let nextY = p.y + p.vy;

                    this.obstacles.forEach(o => {
                        if (nextX + p.r > o.x && nextX - p.r < o.x + o.w && p.y + p.r > o.y && p.y - p.r < o.y + o.h) nextX = p.x;
                        if (p.x + p.r > o.x && p.x - p.r < o.x + o.w && nextY + p.r > o.y && nextY - p.r < o.y + o.h) nextY = p.y;
                    });

                    p.x = Math.max(p.r, Math.min(this.width-p.r, nextX));
                    p.y = Math.max(p.r, Math.min(this.height-p.r, nextY));

                    if (p.portalCooldown > 0) p.portalCooldown--;
                    else {
                        this.portals.forEach(port => {
                            if (Math.hypot(p.x - port.x1, p.y - port.y1) < port.r) {
                                this.spawnTeleportEffect(p.x, p.y, port.color);
                                p.x = port.x2; p.y = port.y2; p.portalCooldown = 60;
                                this.spawnTeleportEffect(p.x, p.y, port.color);
                            } else if (Math.hypot(p.x - port.x2, p.y - port.y2) < port.r) {
                                this.spawnTeleportEffect(p.x, p.y, port.color);
                                p.x = port.x1; p.y = port.y1; p.portalCooldown = 60;
                                this.spawnTeleportEffect(p.x, p.y, port.color);
                            }
                        });
                    }

                    if(p.vx !== 0 || p.vy !== 0) {
                        const mag = Math.hypot(p.vx, p.vy);
                        p.lastDir = { x: p.vx/mag, y: p.vy/mag };
                    }
                    if(p.cooldown > 0) p.cooldown--;
                    if(p.stabTimer > 0) p.stabTimer--;
                });

                this.boomerangs.forEach(b => {
                    if(!b.active) return;
                    b.x += b.vx; b.y += b.vy; b.life++;
                    if(b.life > 45) b.returning = true;

                    if(b.returning) {
                        const dx = b.owner.x - b.x, dy = b.owner.y - b.y, d = Math.hypot(dx, dy);
                        b.vx = (dx/d) * 12; b.vy = (dy/d) * 12;
                        if(d < 30) b.active = false;
                    }

                    this.obstacles.forEach(o => {
                        if(b.x > o.x && b.x < o.x+o.w && b.y > o.y && b.y < o.y+o.h) b.returning = true;
                    });

                    this.players.forEach(p => {
                        if(p.alive && p !== b.owner && Math.hypot(b.x - p.x, b.y - p.y) < p.r + 15) {
                            p.alive = false; b.owner.score++; b.active = false;
                            this.updateScoreBoard(); this.checkRoundEnd();
                        }
                    });
                });

                this.particles.forEach((p, i) => {
                    p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                    if(p.life <= 0) this.particles.splice(i, 1);
                });
            }

            handleInput(p) {
                p.vx = p.vy = 0;
                const speed = 5;
                if(this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) p.vy = -speed;
                if(this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) p.vy = speed;
                if(this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) p.vx = -speed;
                if(this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) p.vx = speed;

                if (this.joystick.active) { p.vx = this.joystick.x * speed; p.vy = this.joystick.y * speed; }

                if(this.keys[' '] && p.cooldown === 0) this.throw(p);
                if((this.keys['x'] || this.keys['X']) && p.stabTimer === 0) this.stab(p);
            }

            handleAI(p) {
                const target = this.players.find(op => op.alive && op !== p);
                if(!target) return;
                const dx = target.x - p.x, dy = target.y - p.y, d = Math.hypot(dx, dy);
                p.vx = (dx/d) * 3.5; p.vy = (dy/d) * 3.5;
                if(d < 400 && p.cooldown === 0 && Math.random() < 0.02) this.throw(p);
                if(d < 70 && p.stabTimer === 0) this.stab(p);
            }

            spawnTeleportEffect(x, y, color) {
                for(let i=0; i<15; i++) {
                    this.particles.push({
                        x, y, 
                        vx: (Math.random()-0.5)*10, 
                        vy: (Math.random()-0.5)*10, 
                        life: 1.0, 
                        color 
                    });
                }
            }

            throw(p) {
                if (!p.alive || p.cooldown > 0) return;
                this.boomerangs.push({ x: p.x, y: p.y, vx: p.lastDir.x * 12, vy: p.lastDir.y * 12, owner: p, active: true, returning: false, life: 0 });
                p.cooldown = 60;
            }

            stab(p) {
                if (!p.alive || p.stabTimer > 0) return;
                p.stabTimer = 25;
                this.players.forEach(op => {
                    if(op.alive && op !== p && Math.hypot(op.x - p.x, op.y - p.y) < 85) {
                        op.alive = false; p.score++; this.updateScoreBoard(); this.checkRoundEnd();
                    }
                });
            }

            checkRoundEnd() {
                if(this.players.filter(p => p.alive).length <= 1) setTimeout(() => this.resetRound(), 2000);
            }

            resetRound() {
                this.boomerangs = [];
                const spawns = [{x: 100, y: 100}, {x: 900, y: 100}, {x: 100, y: 600}, {x: 900, y: 600}];
                this.players.forEach((p, i) => { p.alive = true; p.x = spawns[i].x; p.y = spawns[i].y; p.vx = p.vy = 0; });
                const randomMap = ['pillars', 'arena', 'cross', 'zig'][Math.floor(Math.random() * 4)];
                this.obstacles = this.generateObstacles(randomMap);
                this.updateScoreBoard();
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(this.loop);
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0,0,this.width,this.height);
                ctx.globalAlpha = 1.0;

                this.portals.forEach(port => {
                    // Glow effect
                    ctx.save();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = port.color;
                    ctx.fillStyle = port.color;
                    ctx.beginPath(); ctx.arc(port.x1, port.y1, port.r, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(port.x2, port.y2, port.r, 0, Math.PI*2); ctx.fill();
                    ctx.restore();

                    // Swirl
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 3; ctx.setLineDash([8, 4]);
                    ctx.beginPath(); ctx.arc(port.x1, port.y1, port.r-5, Date.now()/150, Date.now()/150 + Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc(port.x2, port.y2, port.r-5, -Date.now()/150, -Date.now()/150 + Math.PI*2); ctx.stroke();
                    ctx.setLineDash([]);
                });

                this.obstacles.forEach(o => { 
                    ctx.fillStyle = o.color;
                    ctx.beginPath(); ctx.roundRect(o.x, o.y, o.w, o.h, 15); ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.stroke();
                });

                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
                });
                ctx.globalAlpha = 1.0;

                this.boomerangs.forEach(b => {
                    if(!b.active) return;
                    ctx.save(); 
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = '#ffffff';
                    ctx.translate(b.x, b.y); 
                    ctx.rotate(b.life * 0.2); 
                    ctx.font = '40px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'; 
                    ctx.textAlign = 'center'; 
                    ctx.fillText('ü™É', 0, 15); 
                    ctx.restore();
                });

                this.players.forEach(p => {
                    if(!p.alive) {
                        ctx.save();
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '50px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText('üíÄ', p.x, p.y);
                        ctx.restore();
                    } else {
                        // Character base
                        ctx.save();
                        ctx.fillStyle = p.isAI ? 'rgba(0,0,0,0.1)' : 'rgba(99, 102, 241, 0.2)';
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.r + 5, 0, Math.PI*2); ctx.fill();
                        ctx.restore();
                        
                        // FULLY VISIBLE EMOJI
                        ctx.save();
                        ctx.globalAlpha = 1.0; 
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '50px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText(p.char.emoji, p.x, p.y);
                        ctx.restore();
                        
                        if(p.stabTimer > 0) { 
                            ctx.save();
                            ctx.globalAlpha = 1.0;
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '35px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'; 
                            ctx.fillText('üî™', p.x + p.lastDir.x * 50, p.y + p.lastDir.y * 50); 
                            ctx.restore();
                        }
                    }
                });
            }
        }

        let game;
        window.onload = () => { game = new Game(); };
        function startGame() { if(game) game.start(); }
    </script>
</body>
</html>
