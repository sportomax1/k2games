<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roller Coaster: Extreme Ride - K2 games</title>
    <style>
        :root {
            --primary: #6366f1;
            --bg: #0f172a;
            --surface: #1e293b;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Segoe UI', system-ui, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            background: #b3e5fc;
            border-radius: 24px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
            border: 6px solid #334155;
            overflow: hidden;
        }

        canvas { display: block; }

        .back-link {
            position: fixed; top: 20px; left: 20px; color: white; text-decoration: none;
            background: rgba(0, 0, 0, 0.3); padding: 12px 24px; border-radius: 12px; z-index: 1000;
            font-weight: bold; backdrop-filter: blur(10px); transition: 0.2s; border: 1px solid var(--glass-border);
        }
        .back-link:hover { background: rgba(0, 0, 0, 0.5); transform: translateY(-2px); }

        .controls-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 10px 30px; border-radius: 50px;
            font-size: 0.9rem; color: white; backdrop-filter: blur(10px);
            white-space: nowrap; border: 1px solid var(--glass-border);
        }

        .header-ui {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6); padding: 15px 30px; border-radius: 20px;
            backdrop-filter: blur(10px); border: 1px solid var(--glass-border);
            text-align: center;
        }
        .title { font-weight: 900; font-size: 1.2rem; color: #fbbf24; letter-spacing: 1px; }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê HUB</a>

    <div id="game-container">
        <canvas id="gameCanvas" width="1200" height="700"></canvas>
        <div class="header-ui">
            <div class="title">ROLLER COASTER EXTREME</div>
            <div style="font-size: 0.7rem; opacity: 0.7; margin-top: 4px;">ZOO PARK DEMO v1.2</div>
        </div>
        <div class="controls-hint">
            <b>HOLD SPACE</b>: Nitro Turbo Mode ‚Ä¢ <b>WATCH</b>: The Minions & Parking Lot
        </div>
    </div>

    <script>
        class RollerCoasterRide {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 1200;
                this.height = 700;

                this.sun = { x: 1100, y: 100, r: 60 };
                this.clouds = [
                    { x: 200, y: 90, w: 120, h: 50, speed: 0.18 },
                    { x: 500, y: 60, w: 90, h: 38, speed: 0.12 },
                    { x: 800, y: 120, w: 140, h: 60, speed: 0.15 }
                ];

                this.parkedCars = [];
                this.incomingCars = [];
                this.outgoingCars = [];
                this.trackPoints = [];
                this.coasterTrain = [];
                this.parkingSpots = [];
                this.parkingLotY = this.height - 150;
                this.parkingLotH = 150;
                this.minions = [];
                this.time = 0;
                this.fastMode = false;

                this.init();
            }

            init() {
                this.initParkingLot();
                this.initTrack();
                this.initCoasterTrain();
                this.initMinions();
                this.setupInput();
                this.animate();
            }

            initParkingLot() {
                this.parkingSpots = [];
                for (let row = 0; row < 3; row++) {
                    for (let i = 0; i < 10; i++) {
                        this.parkingSpots.push({
                            x: 80 + i * 100 + (row % 2) * 50,
                            y: this.height - 100 - row * 40
                        });
                    }
                }

                const carEmojis = ['üöó', 'üöï', 'üöô', 'üèéÔ∏è', 'üöê', 'üöö', 'üöõ', 'üöú'];
                for (let i = 0; i < this.parkingSpots.length; i++) {
                    if (Math.random() < 0.4) {
                        const spot = this.parkingSpots[i];
                        this.parkedCars.push({
                            x: spot.x, y: spot.y, targetX: spot.x, targetY: spot.y,
                            emoji: carEmojis[i % carEmojis.length],
                            color: `hsl(${(i * 30) % 360}, 70%, 60%)`,
                            state: 'parked', spotIdx: i
                        });
                    }
                }

                setInterval(() => this.cycleCars(), 5000);
            }

            cycleCars() {
                const carEmojis = ['üöó', 'üöï', 'üöô', 'üèéÔ∏è', 'üöê', 'üöö', 'üöõ', 'üöú'];
                
                // Randomly have a car leave
                if (Math.random() < 0.5) {
                    const parked = this.parkedCars.filter(c => c.state === 'parked');
                    if (parked.length > 5) {
                        const car = parked[Math.floor(Math.random() * parked.length)];
                        car.state = 'leaving';
                        car.targetX = this.width + 100;
                        this.outgoingCars.push(car);
                    }
                }

                // Randomly have a new car enter
                if (Math.random() < 0.5) {
                    const emptySpots = this.parkingSpots.filter((s, idx) => !this.parkedCars.some(c => c.spotIdx === idx));
                    if (emptySpots.length > 0) {
                        const spotIdx = this.parkingSpots.indexOf(emptySpots[Math.floor(Math.random() * emptySpots.length)]);
                        this.incomingCars.push({
                            x: -100, y: this.parkingSpots[spotIdx].y,
                            targetX: this.parkingSpots[spotIdx].x,
                            targetY: this.parkingSpots[spotIdx].y,
                            emoji: carEmojis[Math.floor(Math.random() * carEmojis.length)],
                            state: 'entering', spotIdx
                        });
                    }
                }
            }

            initTrack() {
                this.trackPoints = [];
                let x = 100, y = 400;
                // Start
                for (let i = 0; i < 50; i++) this.trackPoints.push({ x: x + i, y: y });
                // Lift Hill
                for (let i = 0; i < 100; i++) this.trackPoints.push({ x: x + 50 + i * 2, y: y - i * 2 });
                // Crest
                let cx = x + 250, cy = y - 200;
                for (let i = 0; i < 40; i++) this.trackPoints.push({ x: cx + i, y: cy - Math.sin(i / 40 * Math.PI) * 30 });
                // Drop
                cx += 40;
                for (let i = 0; i < 80; i++) this.trackPoints.push({ x: cx + i, y: cy + i * 3 });
                // Loop
                cx += 80; cy += 240;
                for (let t = Math.PI; t < Math.PI * 3.1; t += 0.1) {
                    this.trackPoints.push({ x: cx + 60 + Math.cos(t) * 80, y: cy - 80 + Math.sin(t) * 80 });
                }
                // Hills
                cx += 120;
                for (let i = 0; i < 200; i++) {
                    this.trackPoints.push({ x: cx + i, y: cy + Math.sin(i / 50 * Math.PI) * 40 });
                }
                // End
                cx += 200;
                for (let i = 0; i < 100; i++) this.trackPoints.push({ x: cx + i, y: cy });
            }

            initCoasterTrain() {
                const personEmojis = ['üßë‚ÄçüöÄ', 'ü•∑', 'ü§†', 'ü§¥', 'üë∏', 'üßî'];
                for (let i = 0; i < 6; i++) {
                    this.coasterTrain.push({
                        t: 0 - i * 12,
                        emoji: i === 0 ? 'üé¢' : 'üöÉ',
                        person: personEmojis[i % personEmojis.length]
                    });
                }
            }

            initMinions() {
                for (let i = 0; i < 6; i++) {
                    this.minions.push({
                        x: 200 + i * 160,
                        y: this.height - 180 + Math.sin(i) * 15,
                        scale: 0.8 + Math.random() * 0.3,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            setupInput() {
                window.onkeydown = (e) => { if (e.code === 'Space') this.fastMode = true; };
                window.onkeyup = (e) => { if (e.code === 'Space') this.fastMode = false; };
            }

            update() {
                this.time++;
                // Update incoming
                for (let i = this.incomingCars.length - 1; i >= 0; i--) {
                    const c = this.incomingCars[i];
                    c.x += (c.targetX - c.x) * 0.05;
                    if (Math.abs(c.x - c.targetX) < 1) {
                        c.x = c.targetX; c.state = 'parked';
                        this.parkedCars.push(c);
                        this.incomingCars.splice(i, 1);
                    }
                }
                // Update outgoing
                for (let i = this.outgoingCars.length - 1; i >= 0; i--) {
                    const c = this.outgoingCars[i];
                    c.x += 5;
                    if (c.x > this.width + 100) {
                        const idx = this.parkedCars.indexOf(c);
                        if (idx !== -1) this.parkedCars.splice(idx, 1);
                        this.outgoingCars.splice(i, 1);
                    }
                }
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                // Sky
                ctx.fillStyle = '#b3e5fc'; ctx.fillRect(0, 0, this.width, this.height);
                
                // Sun
                ctx.save();
                ctx.shadowBlur = 40; ctx.shadowColor = 'yellow';
                ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(this.sun.x, this.sun.y, 60, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                // Clouds
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                this.clouds.forEach(c => {
                    ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w, c.h, 0, 0, Math.PI * 2); ctx.fill();
                    c.x += c.speed; if (c.x - c.w > this.width) c.x = -c.w;
                });

                // Grass/Parking
                ctx.fillStyle = '#22c55e'; ctx.fillRect(0, this.height - 200, this.width, 200);
                ctx.fillStyle = '#475569'; ctx.fillRect(0, this.height - 150, this.width, 150);
                
                // Parking Lines
                ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 3;
                for (let i = 0; i < 12; i++) {
                    ctx.beginPath(); ctx.moveTo(50 + i * 100, this.height - 150); ctx.lineTo(50 + i * 100, this.height); ctx.stroke();
                }

                // Minions
                this.minions.forEach(m => {
                    ctx.save();
                    ctx.translate(m.x, m.y + Math.sin(this.time * 0.05 + m.phase) * 5);
                    ctx.scale(m.scale, m.scale);
                    // Body
                    ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.ellipse(0, 0, 20, 30, 0, 0, Math.PI * 2); ctx.fill();
                    // Overalls
                    ctx.fillStyle = '#2563eb'; ctx.fillRect(-15, 5, 30, 25);
                    // Eye
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -10, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -10, 3, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                });

                // Cars
                [...this.parkedCars, ...this.incomingCars, ...this.outgoingCars].forEach(c => {
                    ctx.font = '40px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(c.emoji, c.x + 50, c.y + 35);
                });

                // Track
                ctx.strokeStyle = '#334155'; ctx.lineWidth = 10;
                ctx.beginPath();
                this.trackPoints.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                ctx.stroke();
                
                // Ties
                ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 2;
                for (let i = 0; i < this.trackPoints.length; i += 10) {
                    const p = this.trackPoints[i];
                    const next = this.trackPoints[i + 1] || p;
                    const angle = Math.atan2(next.y - p.y, next.x - p.x);
                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(angle);
                    ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, 15); ctx.stroke();
                    ctx.restore();
                }

                // Train
                const trainSpeed = this.fastMode ? 4 : 1.5;
                this.coasterTrain.forEach((car, i) => {
                    car.t += trainSpeed;
                    if (car.t >= this.trackPoints.length) car.t = 0;
                    const idx = Math.max(0, Math.floor(car.t));
                    const p = this.trackPoints[idx];
                    const next = this.trackPoints[idx + 1] || p;
                    const angle = Math.atan2(next.y - p.y, next.x - p.x);

                    ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(angle);
                    ctx.font = '40px Arial'; ctx.textAlign = 'center';
                    ctx.fillText(car.person, 0, -5);
                    ctx.fillText(car.emoji, 0, 20);
                    ctx.restore();
                });
            }

            animate() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        window.onload = () => { window.app = new RollerCoasterRide(); };
    </script>
</body>
</html>
